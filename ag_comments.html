<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ag comments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ag_comments_files/libs/clipboard/clipboard.min.js"></script>
<script src="ag_comments_files/libs/quarto-html/quarto.js"></script>
<script src="ag_comments_files/libs/quarto-html/popper.min.js"></script>
<script src="ag_comments_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ag_comments_files/libs/quarto-html/anchor.min.js"></script>
<link href="ag_comments_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ag_comments_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ag_comments_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ag_comments_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ag_comments_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ag_comments.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ag comments</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="generelt" class="level2">
<h2 class="anchored" data-anchor-id="generelt">Generelt</h2>
<p>Flott arbeid! Kjekt å se alt dere har lært. Dere bruker verktøyene som er tilgjengelige i Quarto slik som kryssreferanser og siteringssystemet. Mye fin kode, men jeg vil anbefale dere å bruke flere chunker. En chunk for hver kommando/pipe. Dette gir større fleksibilitet mht. hva dere vil vise i det endelige dokumentet. Setter dere label: på chunkene er det også mye lettere å finne eventuelle feil.</p>
<p>Diskusjonen og analysen syntes jeg var meget bra.</p>
</section>
<section id="some-points" class="level2">
<h2 class="anchored" data-anchor-id="some-points">some points</h2>
<ul>
<li>Jeg anbefaler dere sterkt å benytte quarto sitt innebygde system med overskrifter (seks ulike nivå). Da kan dere kryssreferere til ulike avnitt, slå av og på nummerering i YAML, atutomatisk generere innholdfortegnelse tec</li>
<li>Satt lang: nb så får vi norsk ordeling i pdf format og også norske ord for Figur, Tabell etc.</li>
<li>Dere leser inn kc_house_data og setter riktig projeksjon helt perfekt. Jeg har satt argumentet show_col_types = FALSE så dere slipper gnål om vektor typer i endelig dokument.</li>
<li>Beregeningenav dist_cdb er veldig elegant.</li>
<li>Satt argumentet quiet = TRUE på st_read() for innlesing av WADOH kartet slik at meldingene derfra ikke forurenser det endelige dokumentet.</li>
<li>Dere behandler også WADOH kartet perfekt.</li>
<li>Jeg anbefaler dere å benytte en chunk per kommando/pipe. Setter dere også label på chunkene blir detmye lettere å finne eventuelle feil.</li>
<li>Se bruken av starts_with() under innlesing av income data. Disse hjelpefunksjonene fra tidyselect pakken kan spare masse skriving.</li>
<li>Å legge race og income til kc_wadoh_map gjør dere unødvendig tungvindt. Kan gjøre direkte vha. to left_join()</li>
<li>Perfekt bruk av spatial join for å overføre område data til husdataene.</li>
<li>Fin bruk av na.omit for å fjerne obeservasjoner med NA verdier.
<ul>
<li><code>tracts10_join[complete.cases(tracts10_join), ]</code> er en annen måte for å oppnå det samme, men <code>na.omit()</code> er jo besnærende kortfattet. Fordelen med <code>complete.cases()</code> er at man kan angi hvilke kolonner man vil sjekke for NA verdier.</li>
</ul></li>
<li>Satt quiet = TRUE for st_write(tracts10_join, “house_data.gpkg” … siden vi ikke trenger denne infoen i det endelige dokumentet</li>
<li>Det går an å kryssreferer til figurer som er satt inn med img tag. Se hva jeg har gjort for fig-2. Dere legger inn caption i dialogboksen og så må dere under fanen Attributes legg inn fig-2 som ID.</li>
<li>Ser at dere har brukt bivariate LISA, tror jeg ville også ha tatt med plain (univariate) LISA med salgspris som variabel.</li>
<li>Under Hedoniske modeller: Lange uttrykk er noe herk. Se forslag til løsning vha. <code>\begin{aligned} \end{aligned}</code></li>
<li>Vil også foreslå å bruke LaTeX og tilhørende <span class="math inline">\(\eqref{}\)</span> for å nummerere uttrykkene. Skal virke med pdf og html output format. Se <a href="https://www.datanovia.com/guide/tools/quarto/cross-references.html">her</a> for detaljer.</li>
<li>Satte vidden på første kolonne i den store regresjonstabellen vha. <code>width(j = 1, width = 2)</code></li>
<li>Satte også en autofit()</li>
<li>Satte ft.arraystretch: 1.2 så blir ikke tabellen fullt så kompakt</li>
<li>Plot av regresjonsmodeller vha. plot(lm(mod1)). Vær klar over which argumentet slik at hvis dere bare trenger fitted values mot residual kan dere skrive plot(lm(mod1), which = 1)</li>
<li>for table_data1 satte jeg antall desimaler til 3. Det er mer enn nok. Tilsvarende for table_data2 og table_data3.</li>
<li>Anselin: Her ser vi et problem med Anselins metode Rao’s score gir ikke noe klart svar på hvilken modell vi bør velge.</li>
<li>Siden dere kokluderer med at SAR er den beste ville jeg bare droppet estimering av SAR modellen</li>
<li>Dropp summary av SAR modellen. For denne er det impacts som skal tolkes.</li>
<li>Det som er av interesse i summary er estimatet av rho. Den kan vi plukke ut fra summary vha.en egenskap ved map() funksjonen. Lar vi .f argumentet være en tekststreng vil map() hente denne frem fra en liste vha. pluck() funksjonen.</li>
<li>For SAR, SDEM og SLX er det impacts som skal tolkes. Det beste er å ikke gjengi summary. Eventuelt bare plukke ut estimert autokorrelasjonsparameter fra summary.</li>
<li>For SEM og OLS kan man bruke summary() og tolke regresjonskoeffisienter på vanlig måte.</li>
<li>LeSage: Hvis det er snakk om et lokalt fenomen så er det SDEM, SEM, SLX og OLS som er de relevante modellen (SAR er ikke en begrenset versjon og har ikke noe her å gjøre). SEM, SLX og OLS er begrensete («restricted») versjoner av SDEM. OLS er begrenset versjon av SEM og også av SLX. Siden dette er restricted versjoner kan de testes mot hverandre vha. likelihood ratio test og i de fleste tilfeller vil vi få et klart svar på hvilken modell vi bør velge. Unntaket er hvis vi finner at både SEM og SLX er bedre enn SDEM og at både SEM og SLX er bedre enn OLS. Da har vi ikke noe klart for hvilken av SEM og SLX som er best (siden disse ikke er restricted versjoner av hverandre). Da må vi ty til likelihood-verdier , AIC eller liknende kriterier.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>